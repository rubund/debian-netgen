# Wishrc startup for ToolScript (netgen)
#
# For installation:  Put this file and also tclnetgen.so into
# directory ${CAD_ROOT}/netgen/tcl/, and set the "load" line below
# to point to the location of tclnetgen.so.  Also see comments
# in shell script "netgen.sh".
#

# Check namespaces for existence of other applications
set UsingMagic 0
set UsingXCircuit 0
set UsingIRSIM 0
set nlist [namespace children]
foreach i $nlist {
   switch $i {
      ::magic { set UsingMagic 1 }
      ::xcircuit { set UsingXCircuit 1 }
      ::irsim { set UsingIRSIM 1 }
   }
}

load TCL_DIR/tclnetgenSHDLIB_EXT

#----------------------------------------------------------------
# Define the "lvs" command as a way of calling the netgen options
# for standard compare, essentially the same as the old "netcomp"
# standalone program.
#----------------------------------------------------------------

proc netgen::lvs { name1 name2 {setupfile setup.tcl} {logfile comp.out}} {

   # Allow name1 or name2 to be a list of {filename cellname}.
   if {[llength $name1] == 2} {
      set file1 [lindex $name1 0]
      set cell1 [lindex $name1 1]
   } else {
      set file1 $name1
      set cell1 $name1
   }
   if {[llength $name2] == 2} {
      set file2 [lindex $name2 0]
      set cell2 [lindex $name2 1]
   } else {
      set file2 $name2
      set cell2 $name2
   }

   puts stdout "Reading netlist file $file1"
   set fnum1 [netgen::readnet $file1]
   puts stdout "Reading netlist file $file2"
   set fnum2 [netgen::readnet $file2]

   set clist1 [cells list $file1]
   set cidx [lsearch -regexp $clist1 ^$cell1$]
   if {$cidx < 0} {
      puts stderr "Cannot find cell $cell1 in file $file1"
      return
   } else {
      set cell1 [lindex $clist1 $cidx]
   }
   set clist2 [cells list $file2]
  set cidx [lsearch -regexp $clist2 ^$cell2$]
   if {$cidx < 0} {
      puts stderr "Cannot find cell $cell2 in file $file2"
      return
   } else {
      set cell2 [lindex $clist2 $cidx]
   }

   if {[file exists $setupfile]} {
      puts stdout "Reading setup file $setupfile"
      source $setupfile
   } else {
      netgen::permute default	;# transistors and resistors
   }

   puts stdout "Comparison output logged to file $logfile"
   netgen::log file $logfile
   netgen::log start
   netgen::log echo off
   set endval [netgen::compare hierarchical "$fnum1 $cell1" "$fnum2 $cell2"]
   if {$endval == {}} {
      netgen::log put "No cells in queue!"
      return
   }
   set properr {}
   while {$endval != {}} {
      netgen::run converge
      netgen::log echo on
      if {[verify equivalent]} {
         netgen::run resolve
	 set result [verify unique]
         if {$result == 0} {
	    netgen::log put "   Networks match locally but not globally.\n"
	    netgen::log put "   Probably connections are swapped.\n"
	    netgen::log put "   Check the end of logfile ${logfile} for implicated nodes.\n"
	    netgen::verify nodes

	    # Flatten the non-matching subcircuit (but not the top-level cells)
            if {[netgen::print queue] != {}} {
	       netgen::log put "  Flattening non-matched subcircuits $endval"
	       netgen::flatten class [lindex $endval 0] $fnum1
	       netgen::flatten class [lindex $endval 1] $fnum2
	    }
	 } else {
            netgen::log echo off
	    if {![equate pins]} {
               netgen::log echo on
	       if {[netgen::print queue] != {}} {
	          # Flatten the non-matching subcircuit
	          netgen::log put "  Flattening pin-mismatched subcircuits $endval"
	          netgen::flatten class [lindex $endval 0] $fnum1
	          netgen::flatten class [lindex $endval 1] $fnum2
	       }
	    } else {
               netgen::log echo on
	    }
	 }
	 if {$result == 2} {lappend properr [lindex $endval 0]}
      } else {
	 # Flatten the non-matching subcircuit (but not the top-level cells)
         if {[netgen::print queue] != {}} {
	    netgen::log put "  Flattening non-matched subcircuits $endval"
	    netgen::flatten class [lindex $endval 0] $fnum1
	    netgen::flatten class [lindex $endval 1] $fnum2
	 }
      }
      netgen::log echo off
      set endval [netgen::compare hierarchical]
   }
   netgen::log end
   puts stdout "Result: " nonewline
   netgen::verify only
   if {$properr != {}} {
      puts stdout "The following cells had property errors: $properr"
   }
   puts stdout "LVS Done."
}

# It is important to make sure no irsim commands overlap with Tcl built-in
# commands, because otherwise the namespace import will fail.

proc pushnamespace { name } {

   set y [namespace eval ${name} info commands ::${name}::*]
   set z [info commands]

   foreach v $y {
      regsub -all {\*} $v {\\*} i
      set x [namespace tail $i]
      if {[lsearch $z $x] < 0} {
         namespace import $i
      } else {
            puts "Warning: ${name} command '$x' use fully-qualified name '$v'"
      }
   }
}

proc popnamespace { name } {
   set z [info commands]
   set l [expr [string length ${name}] + 5]

   while {[set v [lsearch $z ${name}_tcl_*]] >= 0} {
      set y [lindex $z $v]
      set w [string range $y $l end]
      interp alias {} ::$w {}
      rename ::$y ::$w
      puts "Info: replacing ::$w with ::$y"
   }
   namespace forget ::${name}::*
}

set auto_noexec 1       ;# don't EVER call UNIX commands w/o "shell" in front

#----------------------------------------------------------------------
# Cross-Application section
#----------------------------------------------------------------------

# Setup IRSIM assuming that the Tcl version is installed.
# We do not need to rename procedure irsim to NULL because it is
# redefined in a script, which simply overwrites the original.

proc irsim { args } {
   global CAD_ROOT
   set irsimscript [glob -nocomplain ${CAD_ROOT}/irsim/tcl/irsim.tcl]
   if { ${irsimscript} == {} } {
      puts stderr "\"irsim\" requires Tcl-based IRSIM version 9.6 or newer."
      puts stderr "Could not find script \"irsim.tcl\".  If IRSIM is installed in a"
      puts stderr "place other than CAD_ROOT (=${CAD_ROOT}), use the command"
      puts stderr "\"source <path>/irsim.tcl\" before doing \"irsim\"."
   } else {
      source $irsimscript
      eval {irsim} $args
   }
}

# Setup Xcircuit assuming that the Tcl version is installed.

proc xcircuit { args } {
   global CAD_ROOT
   global argc
   global argv
   set xcircscript [glob -nocomplain ${CAD_ROOT}/xcircuit*/xcircuit.tcl]
   if { ${xcircscript} == {} } {
      puts stderr "\"xcircuit\" requires Tcl-based XCircuit version 3.1 or newer."
      puts stderr "Could not find script \"xcircuit.tcl\".  If XCircuit is installed in a"
      puts stderr "place other than CAD_ROOT (=${CAD_ROOT}), use the command"
      puts stderr "\"source <path>/xcircuit.tcl\"."
   } else {
      # if there are multiple installed versions, choose the highest version.
      if {[llength $xcircscript] > 1} {
        set xcircscript [lindex [lsort -decreasing -dictionary $xcircscript] 0]
      }
      set argv $args
      set argc [llength $args]
      uplevel #0 source $xcircscript
   }
}

# Setup Magic assuming that the Tcl version is installed.

proc magic { args } {
   global CAD_ROOT
   global argc
   global argv
   set magicscript [glob -nocomplain ${CAD_ROOT}/magic/tcl/magic.tcl]
   if { ${magicscript} == {} } {
      puts stderr "\"magic\" requires Tcl-based Magic version 7.2 or newer."
      puts stderr "Could not find script \"magic.tcl\".  If Magic is installed in a"
      puts stderr "place other than CAD_ROOT (=${CAD_ROOT}), use the command"
      puts stderr "\"source <path>/magic.tcl\"."
   } else {
      set argv $args
      set argc [llength $args]
      uplevel #0 source $magicscript
   }
}

#----------------------------------------------------------------------------
# Have we called netgen from tkcon or a clone thereof?  If so, set NetgenConsole
#----------------------------------------------------------------------------

if {! $UsingMagic } {
   if {[lsearch [interp aliases] tkcon] != -1} {
      set NetgenConsole tkcon
      wm withdraw .
   }
}

pushnamespace netgen

#----------------------------------------------------------------------------
# For now, if we are standalone, pop down the default Tk window.
# Sometime later we may wish to provide a standalone GUI frontend in Tk
# to improve upon the original X11 "xnetgen" frontend.  If so, its
# definitions would go below.

if {! $UsingMagic } {
   if {[lsearch [interp aliases] tkcon] != -1} {
      if {[string range [wm title .] 0 3] == "wish"} {
	 wm withdraw .
      }
   }
}

#----------------------------------------------------------------------------
# Anything on the command line is assumed to be a netgen command to evaluate
catch {eval $argv}

#----------------------------------------------------------------------------
# Netgen start function drops back to interpreter after initialization & setup
